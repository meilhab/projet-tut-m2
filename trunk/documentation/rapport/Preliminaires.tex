
\definecolor{gris}{gray}{0.5}
\lstset{
	numbers=left,
	numberstyle=\footnotesize,
%	numberstyle=Sepia,
	stepnumber=2,
	numbersep=5pt,
	frame=shadowbox,
	backgroundcolor=\color{grisclair},
	rulesepcolor=\color{gris}
}

\chapter{Préliminaires}

\section{SysML : System Modeling Language}

\subsection{Contexte}

Les méthodes de l'Ingénierie Système (IS) reposent sur des approches de modélisation et de simulation pour valider les exigences, et pour vérifier ou évaluer le système. La modélisation a donc couramment été utilisée pour l'IS, que ce soit pour des représentations concrètes avec des plans ou modèles réduits, ou plus abstraites avec des systèmes d'équations.\\
Les spécifications issues de l'IS produisant souvent une documentation très dense, une façon de la simplifier est d'utiliser une approche orient{\'e}e modèles. Elle permet de r{\'e}aliser un mod{\`e}le cohérent du syst{\`e}me, stock{\'e} et g{\'e}r{\'e} dans un r{\'e}f{\'e}rentiel.\\
La mod{\'e}lisation permet de ma{\^i}triser la complexit{\'e} du syst{\`e}me {\'e}tudi{\'e}, car chaque mod{\`e}le donne acc{\`e}s {\`a} une repr{\'e}sentation abstraite de diff{\'e}rents aspects du syst{\`e}me.

\subsection{Pourquoi SysML ?}

La mod{\'e}lisation avec le langage UML~\cite{siteUML} est une pratique bien {\'e}tablie dans l'industrie logicielle. Bien que le langage UML permette par son caract{\`e}re {\`a} usage g{\'e}n{\'e}ral d'adresser de nombreux besoins pour l'IS, il ne r{\'e}pond pas {\`a} tous les besoins.\\
SysML apporte une simplification et une standardisation du vocabulaire, plus question ici de classes, d'objets, ou d'h{\'e}ritage. Ce nouveau langage, ajoute aussi la possibilit{\'e} de repr{\'e}senter les exigences du syst{\`e}me comme elles sont d{\'e}finies dans un cahier des charges, les {\'e}l{\'e}ments non-logiciels (m{\'e}canique, hydraulique, capteur \dots), les {\'e}quations physiques, les flux continus (mati{\`e}re, {\'e}nergie, etc.) et les allocations.

\subsection{SysML}

Systems Modeling Language (SysML~\cite{siteSysML}) est bas{\'e} sur UML et remplace la mod{\'e}lisation de classes et d'objets par la mod{\'e}lisation de blocs pour un vocabulaire plus adapt{\'e} {\`a} l'Ing{\'e}nierie Syst{\`e}me. Un bloc englobe tout concept logiciel, mat{\'e}riel, donn{\'e}es, processus, et m{\^e}me la gestion des personnes.

Le projet SysML a {\'e}t{\'e} men{\'e} conjointement entre l'INCOSE~\cite{siteINCOSE} (International Council on Systems Engineering) et l'OMG (Object Management Group), organisme responsable d'UML, et a {\'e}t{\'e} valid{\'e} en 2006. Depuis il fut repris jusque arriver {\`a} une \textit{Final Adopted Specification} telle que le d{\'e}fini l'OMG~\cite{siteOMG}. La version actuelle (1.2) date de juin 2010.

\subsection{Diff{\'e}rences entre SysML et UML}

SysML r{\'e}utilise certaines fonctionnalit{\'e}s d'UML mais en les simplifiant en plus d'en int{\'e}grer de nouvelles. 
\noindent Ce qui peut {\^e}tre repr{\'e}sent{\'e} sous la forme du diagramme présenté par la figure~\ref{UMLSysML} ci-dessous.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{image3.png}
	\caption{UML vs SysML}
	\label{UMLSysML}

\end{figure}

\noindent UML4SysML :
\begin{itemize}
	\item diagramme de s{\'e}quences;
	\item diagramme d'{\'e}tats;
	\item diagramme de cas d'utilisations;
	\item diagramme d'activit{\'e}s;
	\item diagramme de paquetage;
	\item diagrammes de classe et structure composite (utilis{\'e}s pour les diagrammes de d{\'e}finitions de blocs et de bloc interne) BDD\protect\footnote{Block Definition Diagram} \& IDB\protect\footnote{Block Definition Diagram}.

\end{itemize}

\noindent Extensions SysML  :
\begin{itemize}
	\item d{\'e}finitions pour les diagrammes de d{\'e}finitions de blocs et de bloc interne - BDD \& IDB;
	\item modifications dans le diagramme d'activit{\'e}s;
	\item diagramme d'exigences (requirements) - Nouveau;
	\item diagramme param{\'e}trique - Nouveau;
	\item allocations (tra\c{c}abilit{\'e}) - Nouveau.

\end{itemize}


\subsection{Structure de SysML}

SysML comprend donc 9 diagrammes dont 4 sont structurels, 4 dynamiques, et un diagramme d'exigences:
\begin{itemize}
	\item Structurels
	\begin{itemize}
		\renewcommand{\labelitemii}{$\bullet$}
		\item Le BDD remplace le diagramme de classes;
		\item L'IBD remplace le diagramme de structure composite;
		\item Le diagramme de paquetage reste inchang{\'e};
		\item Le diagramme param{\'e}trique est une extension SysML pour l'analyse de param{\`e}tres critiques du syst{\`e}me.

	\end{itemize}
	
	\item Dynamiques
	\begin{itemize}
		\renewcommand{\labelitemii}{$\bullet$}
		\item Le diagramme d'activit{\'e}s est l{\'e}g{\`e}rement modifi{\'e} pour SysML;
		\item Les diagrammes de s{\'e}quences, d'{\'e}tats, et de cas d'utilisations restent inchang{\'e}s.

	\end{itemize}
	
\item Le diagramme d'exigences est une extension SysML.

\end{itemize}

La structure de SysML peut {\^e}tre d{\'e}compos{\'e}e via le diagramme présenté par la figure~\ref{Description des diagrammes SysML}.

\begin{figure}[!ht]
	\centering 
	\includegraphics[scale=0.6]{image5.jpg}
	\caption{Description des diagrammes SysML}
	\label{Description des diagrammes SysML}

\end{figure}

\subsection{Exemples de diagrammes}

Afin d'illustrer SysML de façon concr{\`e}te, la suite pr{\'e}sentera deux diagrammes repr{\'e}sentatifs : un diagramme BDD et un diagramme IBD.

\subsubsection{Diagramme BDD}
	
Le diagramme BDD repr{\'e}sente une vue d{\^i}te bo{\^i}te noire d'un bloc. Il pr{\'e}sente les blocs et les relations entre eux. Par rapport {\`a} UML, le diagramme BDD red{\'e}fini le diagramme de classes en rempla\c{c}ant les classes par des blocs. 
	
\noindent Le diagramme BDD de la figure~\ref{Exemple de diagramme BDD d'un purificateur d'eau} ci-dessous provient de l'exemple OMG d'un purificateur d'eau.\\

\begin{figure}[!ht]
	\centering 
	\includegraphics[scale=0.4]{image6.png}
	\caption{Exemple de diagramme BDD d'un purificateur d'eau}
	\label{Exemple de diagramme BDD d'un purificateur d'eau}

\end{figure}

\noindent Les blocs peuvent {\^e}tre en relation les uns avec les autres.\\
Ils ont aussi des ports d'entr{\'e}e/sortie qui permettent de simuler des {\'e}l{\'e}ments requis et fournis entre les blocs. Ainsi, le bloc \enquote{Distiller} a besoin d'eau froide en entr{\'e}e et de chaleur externe pour produire en sortie de l'eau purifi{\'e}e, du r{\'e}sidu, et de l'eau pour le bypass.

\subsubsection{Diagramme IBD} 

Le diagramme IBD repr{\'e}sente la vue bo{\^i}te blanche d'un bloc, c'est-{\`a}-dire la description de la vue interne d'un bloc. Il pr{\'e}sente les blocs composants le bloc principal et la fa\c{c}on dont ils sont assembl{\'e}s ensemble via des ports.  Par rapport {\`a} UML, le diagramme IBD red{\'e}fini le diagramme de structure composite. Le diagramme IBD ci-dessous provient de l'exemple OMG du purificateur d'eau, et correspond au diagramme de d{\'e}finition de bloc BDD présenté par la figure~\ref{Exemple de diagramme BDD d'un purificateur d'eau}.

Le diagramme IBD permet d'obtenir le fonctionnement interne du composant et les interactions des composants qui le composent avec les ports d'entr{\'e}e/sortie. La figure~\ref{Exemple de diagramme IBD du bloc Distiller} présente un exemple de diagramme IBD.

\begin{figure}[!ht]
	\centering 
	\includegraphics[scale=0.4]{image8.png}
	\caption{Exemple de diagramme IBD du bloc Distiller}
	\label{Exemple de diagramme IBD du bloc Distiller}

\end{figure}

\subsection{Outils SysML}

Le langage SysML a {\'e}t{\'e} int{\'e}gr{\'e} dans de nombreux outils AGL\protect\footnote{Atelier de Génie Logiciel}, commerciaux ou open source:
\begin{itemize}
	\item Sparx Systems Enterprise Architect (plugin SysML ou version Ultimate requise);
	\item IBM Rational Software Modeler (plugin d'une soci{\'e}t{\'e} tierce disponible);
	\item Magicdraw (plugin SysML requis);
	\item Open source: Topcased (environnement Eclipse).

\end{itemize}

\section{TopCased}

L'IDE\protect\footnote{Integrated Development Environment} Topcased\protect\footnote{Toolkit in Open Source for Critical Applications \& Systems Development}~\cite{siteTopcased} propose des outils intéressants et facilement exploitables pour l'ingénierie système. Sont implémentés (ou en cours d'implémentation) des moyens d'analyse d'exigences, modélisation, simulation de modèles, implémentation, test, validation, rétro-ingénierie, génération de code, de modèles et de documentation, et gestion de projet.

On le trouve soit sous forme de plugin d'eclipse, soit en tant qu'application RCP\protect\footnote{Rich Client Platform}. Il contient donc un IDE basé sur le framework de la plate forme de développement Eclipse, à laquelle il ajoute des fonctionnalités essentiellement liées à la mise en \oe{}uvre de la première branche du cycle en V pour l'ingénierie du logiciel, du matériel ou de systèmes mixtes logiciel/matériel.

S'appuyant principalement sur des langages standardisés pour la modélisation du logiciel (UML, SysML, AADL, \dots{}), Topcased travaille avec des fichiers XMI\protect\footnote{XML Metadata Interchange}. Tous ses standards sont implémentés dans leurs dernières versions stables, soit directement par le projet Topcased, soit par les modules de la dernière version stable de la plate-forme Eclipse. Sa dernière version étant la 5.1.0, basée sur Eclipse 3.7.1 (Indigo). La figure~\ref{exempleModelisationTopcased} montre différentes modélisations possibles avec Topcased.

%\clearpage

\begin{figure}[!ht]
	\centering 
	\includegraphics[scale=0.5]{viewer.png}
	\caption{Exemples de modélisation avec Topcased}
	\label{exempleModelisationTopcased}

\end{figure}

\section{Ticc}

\subsection{Qu'est ce que Ticc ?}

Ticc~\protect\footnote{Tool for Interface Compatibility and Composition}~\cite{siteTicc, ticcDocumentation} est un outil qui permet de définir des interfaces (appelées modules) et de les composer ensembles. Il est écrit en OCaml et est disponible gratuitement. Il utilise le modèle à composants d'Alfaro et Henzinger défini dans~\ref{sectionAutomateInterface}.

\noindent Ticc fournit les fonctions suivantes :
\begin{itemize}
	\item La modélisation des composants de conception et leurs interactions : 
	\begin{itemize}
		\renewcommand{\labelitemii}{$\bullet$}
		\item Chaque composant peut spécifier son comportement, ainsi que le comportement attendu des autres composants;
		\item Les fonctionnalités du modèle intègrent des états partagés (via la visibilité des variables : partagé ou privé), une communication et une synchronisation uni ou bi-directionnelle (via la synchronisation des actions);
		\item Avantage : il est concis.

	\end{itemize}
	
	\item La composition et la vérification de la compatibilité : 
	\begin{itemize}
		\renewcommand{\labelitemii}{$\bullet$}
		\item Lorsque les composants sont assemblés, Ticc vérifie qu'ils interagissent correctement;
		\item Ticc est capable de propager les contraintes d'entrée des composants lors de la composition;
		\item Avantage : la cohérence du modèle est assurée.

	\end{itemize}
	
	\item La simulation et la vérification :
	\begin{itemize}
		\renewcommand{\labelitemii}{$\bullet$}
		\item Ticc peut vérifier les propriétés CTL\protect\footnote{Computational Tree Logic} des modèles, ainsi que les simuler;
		\item Ticc s'appuie sur les méthodes symboliques pour une analyse efficace des espaces d'états;
		\item Avantage : la justesse des modèles et le respect des spécifications peuvent être vérifiées. 

	\end{itemize}  

\end{itemize} 

Cet outil a été créé par Luca de Alfaro, Bo Adler, Marco Faella, Axel Legay, Vishwanath Raman, Leandro Dias Da Silva, et Pritam Roy. Ticc est en développement constant, et des versions sont régulièrement mises à jour avec de nouvelles fonctionnalités. La version actuelle est la 0.3.

\subsection{Un exemple d'utilisation de Ticc}
\label{utilisationTicc}

Afin de pouvoir faire des opération sur des modèles, Ticc doit prendre en entrée deux fichiers différents : 
\begin{itemize}
	\item un \enquote{.si} : qui contient le modèle (connut également sous \enquote{sociable interface});
	\item un \enquote{.in} : qui contient  le code OCaml qui permet de charger le modèle et y faire des opérations.

\end{itemize} 

\subsubsection{Le modèle}

\lstinputlisting{./doc/fire-detector.si}

Ce modèle illustre un détecteur de fumée et sa centrale d'alarme. La centrale d'alarme collecte les alarmes des détecteurs de fumées, et envoie un message aux pompiers (ControlUnit) s'il y a une alarme déclenchée.

\subsubsection{Le code OCaml}

\lstinputlisting{./doc/fire-detector.in}

Ce script  Ocaml montre le chargement du modèle depuis le fichier « fire-detector.si », l'instanciation des modules, et leur composition.

\subsubsection{Approche de la compatibilité}

Lors de la composition de deux interfaces des composants \textit{FireDetection} et \textit{ControlUnit}, on doit s'assurer que les contraintes de sorties de \textit{FireDetection} respectent les contraintes d'entrées de \textit{ControlUnit}, et vice versa.\\
On peut remarquer dans l'exemple de la figure~\ref{Detecteur de Fumee} que les deux automates d'interface sont incompatibles car l'un produit un événement \enquote{FD!} alors que l'autre non.

\begin{figure}[!ht]
	\begin{center}
		\begin{minipage}{0.3\linewidth}
		\centering \includegraphics[scale=0.68]{fireDetector.png}
		\end{minipage}
		\hfill
		\begin{minipage}{0.3\linewidth}
		\centering \includegraphics[scale=0.68]{controlUnit.png}
		\end{minipage}
		\caption{Detecteur de Fumée}
	\end{center}
\end{figure}

\clearpage
