-- @path SequenceMetaModel=/Transformation2/MetamodelSeq/SequenceMetamodel.ecore
-- @path TiccMetaModel=/Transformations/MetamodelTicc/TiccModel.ecore

module SequenceToTicc;
create OUT : TiccMetaModel from IN : SequenceMetaModel;

helper context SequenceMetaModel!Sequences def : isSequenceRoot() : Boolean =
	self.refImmediateComposite().oclIsUndefined();

rule SequenceToModule{
	from s : SequenceMetaModel!Sequences
	to t : TiccMetaModel!Module (
		--nom <- s.nom,
		--TODO: faire 2 sequences et test si root bien détecté
		--TODO: controle premier message pour point d'entrée initial automate
		nom <- s.isSequenceRoot().toString(),
		transition <- s.isComposedBy,
		nbEtat <- SequenceMetaModel!NamedElement.allInstances()->asSet()->size(),
		etatInitial <- 0
	)
}

rule MessageToLocalInput{
	from s : SequenceMetaModel!Message(s.receiveFrom.nom = 'environnement')
	to t : TiccMetaModel!LocalInput(
		nom <- s.calls.nom,
		source <- s.receiveFrom.nom,
		destination <- s.sendTo.nom
	)
}

rule MessageToOutput{
	from s : SequenceMetaModel!Message(s.sendTo.nom = 'environnement')
	to t : TiccMetaModel!Output(
		nom <- s.calls.nom,
		source <- s.receiveFrom.nom,
		destination <- s.sendTo.nom
	)
}

rule SequenceDiagramToTicc{
	from s : SequenceMetaModel!SequenceDiagram
	to t : TiccMetaModel!Ticc(
		possede <- s.contain	
	)
}

