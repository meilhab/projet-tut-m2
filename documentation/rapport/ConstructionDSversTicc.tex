\newpage
\chapter{Construction d'automates d'interfaces}

Le but principal du projet est, partant d'un diagramme de définition de blocs, de récupérer deux blocs interagissant ensembles et de pouvoir valider le fait qu'ils soient compatibles l'un avec l'autre.

Les automates d'interfaces des composants permettent de tester si deux composants sont compatibles. L'outil Ticc sera utilisé afin de tester la compatibilité entre deux automates d'interfaces. 
Le diagramme de séquences d'un bloc SysML est connu, il faut donc obtenir d'après ce diagramme de séquences, un fichier pouvant être lu par Ticc.
ATL entre en jeu à ce moment, il permet d'effectuer des transformations de modèles : ici le passage d'un diagramme de séquences à un fichier correspondant à la syntaxe de Ticc. 

\noindent En récapitulant, pour tester la compatibilité de deux blocs il faut :
\begin{itemize}
    \item générer un méta modèle du diagramme de séquences;
    \item générer un méta modèle correspondant à la syntaxe de Ticc;
    \item écrire les règles ATL permettant le passage d'un diagramme de séquences à un fichier Ticc;
    \item appliquer les règles ATL sur un fichier contenant les diagrammes de séquences de deux blocs (appelés par la suite composants), ce fichier doit être conforme au méta modèle du diagramme de séquences;
    \item parser le fichier obtenu après application des règles pour obtenir un fichier compatible Ticc contenant les deux composants;
    \item générer un fichier d'exécution Ticc;
    \item lancer le fichier d'exécution dans Ticc et conclure sur la compatibilité des composants.

\end{itemize}

\input{TransformationModeles}

\section{Réalisation}

\subsection{Utilisation du langage ATL}

L'utilisation d'ATL, pour la récupération et le traitement d'un fichier Ticc contenant deux composants, requiert :
\begin{itemize}
    \item deux méta modèles en entrée : un de base (celui du diagramme de séquences) et un d'arrivé (celui du langage Ticc);
    \item un fichier conforme au méta modèle de base;
    \item les règles ATL permettant de passer du méta modèle de base au méta modèle voulu.

\end{itemize}

\subsubsection{Méta modèle du diagramme de séquences}
\label{subsubMMDiagSeq}

Le méta modèle de séquence existant n'a pas été pris dans son ensemble, seules les parties importantes ont été extraites.
Par principe, les messages échangés se font entre un composant et son environnement.

\noindent Les ensembles de messages pris en compte sont :
\begin{itemize}
    \item \textbf{alt} : messages multiples alternatifs (si alors sinon);
    \item \textbf{loop} : messages s'exécutant plusieurs fois (boucle);
    \item \textbf{seq} : messages n'ayant pas d'ordre particulier.

\end{itemize}
Ces ensembles peuvent contenir eux-mêmes d'autres ensembles contenant des messages. Un message est composé d'un émetteur et d'un récepteur. Il possède aussi une méthode associée qui possède un nom.

Une séquence type pour le diagramme de séquences, dont il est question d'utiliser dans le cadre du projet, sera composée de différents composants \textit{NamedElement}, de messages \textit{Message} et éventuellement d'ensembles de messages \textit{TypeMessage}.
La figure~\ref{figureMMDiagSeq} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.62]{MMDiagSeq.jpg}
	\caption{Méta modèle du diagramme de séquences utile pour le projet}
	\label{figureMMDiagSeq}

\end{figure}

\subsubsection{Méta modèle du langage de Ticc}

Concernant Ticc, le méta modèle a été créé en se basant sur la syntaxe du logiciel et après analyse des fichiers exemples. En effet, Ticc permet de traiter des automates dît sociaux, pouvant communiquer entre eux. Or cette notion n'est pas utile dans le cadre du projet, elle a donc, de ce fait, été écartée du méta modèle.

Le code ci-dessous représente comme vu dans la partie~\ref{utilisationTicc} un module.
\lstinputlisting{./doc/moduleExemple.si}

Un module porte un nom et est donc composé d'un tableau représentant les différents états de l'automate. Il peut aussi avoir un état initial.
Il contient ensuite les différentes transitions possibles de l'automate :
\begin{itemize}
	\item \textbf{Input} une transition d'entrée de l'automate qui peut être décomposée en deux types :
	\begin{itemize}
		\item[$\bullet$] \textbf{GlobalInput} principalement utilisée pour les automates sociaux, elle peut représenter aussi des entrées ne faisant pas changer l'état de l'automate;
		\item[$\bullet$] \textbf{LocalInput} cette transition représente une entrée dans l'automate entrainant ou non un changement d'état interne.
	
	\end{itemize}
	\item \textbf{Output} une transition de sortie de l'automate;
	\item \textbf{Local} une transition interne de l'automate.
				
\end{itemize}

Dans le cas d'un changement d'état, l'état suivant est noté d'un \' (voir l'exemple ci-dessus avec \textbf{s'}).

\noindent La figure~\ref{figureMMTicc} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.62]{MMTicc.jpg}
	\caption{Méta modèle de la syntaxe de Ticc utile pour le projet}
	\label{figureMMTicc}

\end{figure}

\subsubsection{Fichier type exemple}
%TODO a completer

\subsubsection{Les règles ATL}

Après génération des deux méta modèles intervient l'écriture des règles ATL permettant le passage d'un diagramme de séquences à un automate d'interface.

Un algorithme permettant le passage d'un diagramme de séquences en un automate d'interface était fourni en début de projet. Cependant l'application d'un algorithme itératif récursif en règles ATL n'est pas possible du fait de la conception d'ATL utilisant EMF\protect\footnote{Eclipse Modeling Framework : framework de modélisation d'eclipse} qui utilise des modèles de données structurées.

Pour l'exécution d'ATL, ce qu'il faut savoir c'est qu'il prend en entrée un fichier de type \textit{XMI}\protect\footnote{XML Metadata Interchange : format standard de représentation de modèles UML basé sur XML} et génère en sortie un fichier du même type. Un exemple de fichier d'entrée XMI peut être trouvé en annexe.
%TODO: METTRE LA REFERENCE A L'ANNEXE !!!

Comme annoncé en début de~\ref{subsubMMDiagSeq}, les échanges d'un composant se font entre lui et un composant abstrait appelé \textit{Environnement}. Il représente tous les autres composants émettant ou réceptionnant des messages du composant étudié dans la séquence.

\noindent Les règles sont les suivantes : 
\begin{itemize}
	\item Le diagramme de séquences devient un modèle Ticc;
	\item Les séquences du diagramme de séquences deviennent des modules;
	\item Les messages en fonction de l'émetteur et du récepteur deviennent des transitions d'entrée ou de sortie : un message provenant du composant \textit{Environnement} correspond à une transition d'entrée.

\end{itemize}

% ANNEXE !!!!
Le fichier d'entrée exemple, le fichier des règles ATL et le fichier de sortie sont disponibles en annexes.

\subsection{Parseur XML vers Ticc}

Afin de pouvoir utiliser Ticc pour vérifier la compatibilité des composants, il est nécessaire de convertir le fichier XMI obtenu en sortie en un fichier .si compatible avec Ticc. Pour ce faire, un parseur XML a été implémenté. 
Il permet de récupérer un fichier XMI en entrée, et s'il est syntaxiquement correcte, un fichier .si associé est généré ainsi qu'un fichier d'exécution .in. \\

\label{compatibiliteAutomate}

\subsection{Processus de transformation}
\noindent Comme déjà établi tout au long du rapport, le schéma~\ref{ProcessusTransformation} ci-dessous permet de visualiser les différentes étapes de transformations de modèles, ainsi que l'implémentation réalisée dans le projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.7]{ProcessusTransformation2.png}
	\caption{Processus de transformation d'un diagramme SysML en automate d'interface Ticc}
	\label{ProcessusTransformation}

\end{figure}

\clearpage
