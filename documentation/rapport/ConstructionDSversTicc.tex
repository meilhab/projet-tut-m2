\chapter{Construction d'automates d'interface}

Partant d'un diagramme de définition de blocs, le but principal du projet est de récupérer deux blocs interagissant ensemble et de pouvoir valider le fait qu'ils soient compatibles l'un avec l'autre.

Les automates d'interface des composants permettent de décrire les compatibilités des composants. L'outil Ticc sera utilisé afin de tester la compatibilité entre deux automates d'interface. 
Le diagramme de séquences d'un bloc SysML est connu, il faut donc obtenir d'après ce diagramme de séquences, un fichier pouvant être lu par Ticc.
ATL entre en jeu à ce moment, il permet d'effectuer des transformations de modèles : ici le passage d'un diagramme de séquences à un fichier correspondant à la syntaxe de Ticc. 

\noindent En récapitulant, pour tester la compatibilité de deux blocs il faut :
\begin{itemize}
    \item générer un méta modèle du diagramme de séquences;
    \item générer un méta modèle correspondant à la syntaxe de Ticc;
    \item écrire les règles ATL permettant le passage d'un diagramme de séquences à un fichier Ticc;
    \item appliquer les règles ATL sur un fichier contenant les diagrammes de séquences de deux blocs (appelés par la suite composants), ce fichier doit être conforme au méta modèle du diagramme de séquences;
    \item parser le fichier obtenu après application des règles pour obtenir un fichier compatible Ticc contenant les deux composants;
    \item générer un fichier d'exécution Ticc en OCaml;
    \item lancer le fichier d'exécution dans Ticc et conclure sur la compatibilité des composants.

\end{itemize}

\section{Introduction {\`a} la transformation de mod{\`e}les}

Parmi les nombreux sujets de recherche existants, la conception et l'utilisation de mod{\`e}les font parti de ceux qui sont en pleine expansion. Le but de cette recherche {\'e}tant l'utilisation continue et syst{\'e}matique de ces mod{\`e}les tout au long d'un projet. L'un des aspects les plus importants est la g{\'e}n{\'e}ration et la transformation de mod{\`e}les {\`a} partir de r{\`e}gles. Il sera ainsi pr{\'e}sent{\'e} dans la suite de cette section, les diff{\'e}rentes approches de la transformation de mod{\`e}les, dont le but est d'introduire la transformation d'un diagramme de s{\'e}quence SysML vers un automate d'interface Ticc.

\subsection{Transformation endog{\`e}ne}

Une transformation endog{\`e}ne (ou raffinement) de mod{\`e}le consiste {\`a} modifier le contenu d'un mod{\`e}le sans en changer le but ou la s{\'e}mantique. Il s'agit de rajouter des d{\'e}tails {\`a} un mod{\`e}le ou bien de le restructurer pour en am{\'e}liorer la conception. Par principe, le raffinement implique que les deux mod{\`e}les, le mod{\`e}le source et le mod{\`e}le cible, soient du m{\^e}me type, c'est-{\`a}-dire conformes au m{\^e}me m{\'e}ta mod{\`e}le.

\noindent La figure~\ref{raffinement} ci-dessous repr{\'e}sente ce concept :

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.8]{endogene.png}
	\caption{Sch{\'e}ma d'une transformation endog{\`e}ne (ou par raffinement)}
	\label{raffinement}

\end{figure}

\subsection{Transformation exog{\`e}ne}

Il s'agit d'une transformation entre deux espaces technologiques diff{\'e}rents. Les mod{\`e}les source et cible sont conformes {\`a} des m{\'e}ta-mod{\`e}les diff{\'e}rents. Par exemple la conversion d'un fichier XML en un sch{\'e}ma BDD.

\clearpage

\noindent C'est cette configuration de transformation qui a {\'e}t{\'e} mise en {\oe}uvre dans le projet. La figure~\ref{projection} ci-dessous repr{\'e}sente ce concept : 

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.8]{exogene.png}
	\caption{Sch{\'e}ma d'une transformation exog{\`e}ne (ou par projection)}
	\label{projection}

\end{figure}

\subsection{Transformation g{\'e}n{\'e}rique}

Ce type de transformation se base sur les m{\'e}ta m{\'e}ta mod{\`e}les (mod{\`e}le MOF\protect\footnote{Meta-Object Facility}) et produit un mod{\`e}le cible g{\'e}n{\'e}rique, qui peut {\^e}tre r{\'e}utilisable. Elle peut {\^e}tre exog{\`e}ne ou endog{\`e}ne.

\subsection{Query}

La transformation de mod{\`e}le query est un type de transformation qui permet la transformation d'un m{\'e}ta mod{\`e}le en texte (documentation ou code source).

\noindent Par exemple :
\begin{itemize}
	\item transformer un mod{\`e}le UML vers du code Java;
	\item contr{\^o}ler la coh{\'e}rence d'un mod{\`e}le UML en écrivant une transformation qui affiche un diagnostic.
	
\end{itemize}

\section{Réalisation}

\subsection{ATL : un choix technique}

L'utilisation d'ATL, pour la récupération et le traitement d'un fichier Ticc contenant deux composants, requiert :
\begin{itemize}
    \item deux méta modèles en entrée : un de base (celui du diagramme de séquences) et un d'arrivé (celui du langage Ticc);
    \item un fichier conforme au méta modèle de base;
    \item les règles ATL permettant de passer du méta modèle de base au méta modèle voulu.

\end{itemize}

\subsection{Les méta modèles}

\subsubsection{Méta modèle du diagramme de séquences}
\label{subsubMMDiagSeq}

Le méta modèle du diagramme de séquence existant n'a pas été pris dans son ensemble, seules les parties importantes ont été extraites.
Par principe, les messages échangés se font entre un composant et son environnement.

\noindent Les ensembles de messages pris en compte sont :
\begin{itemize}
    \item \textbf{alt} : messages multiples alternatifs (si alors sinon);
    \item \textbf{loop} : messages s'exécutant plusieurs fois (boucle);
    \item \textbf{seq} : messages ayant un ordre à respecter.

\end{itemize}

Ces ensembles peuvent contenir eux-mêmes d'autres ensembles contenant des messages. Un message est composé d'un émetteur et d'un récepteur. Il possède aussi une méthode associée qui possède un nom.

Une séquence type pour le diagramme de séquences, dont il est question d'utiliser dans le cadre du projet, sera composée de différents composants \textit{NamedElement}, de messages \textit{Message} et éventuellement d'ensembles de messages \textit{TypeMessage}.
La figure~\ref{figureMMDiagSeq} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.75]{MMDiagSeq.jpg}
	\caption{Méta modèle du diagramme de séquences utile pour le projet}
	\label{figureMMDiagSeq}

\end{figure}

\subsubsection{Méta modèle du langage de Ticc}

Concernant Ticc, le méta modèle a été créé en se basant sur la syntaxe du logiciel et après analyse des fichiers exemples. En effet, Ticc permet de traiter des automates dît sociaux, pouvant communiquer entre eux. Or cette notion n'est pas utile dans le cadre du projet, elle a donc, de ce fait, été écartée du méta modèle.

Le code ci-dessous représente un module, comme vu dans la partie~\ref{utilisationTicc}.
\lstinputlisting{./doc/moduleExemple.si}

Un module porte un nom et est donc composé d'un tableau représentant les différents états de l'automate. Il peut aussi avoir un état initial.
Il contient ensuite les différentes transitions possibles de l'automate :
\begin{itemize}
	\item \textbf{Input} une transition d'entrée de l'automate qui peut être décomposée en deux types :
	\begin{itemize}
		\item[$\bullet$] \textbf{GlobalInput} principalement utilisée pour les automates sociaux, elle peut représenter aussi des entrées ne faisant pas changer l'état de l'automate;
		\item[$\bullet$] \textbf{LocalInput} cette transition représente une entrée dans l'automate entrainant ou non un changement d'état interne.
	
	\end{itemize}
	\item \textbf{Output} une transition de sortie de l'automate;
	\item \textbf{Local} une transition interne de l'automate.
				
\end{itemize}

Dans le cas d'un changement d'état, l'état suivant est noté d'un \enquote{'} (voir l'exemple ci-dessus avec \textbf{s'}).

\clearpage

\noindent La figure~\ref{figureMMTicc} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.7]{MMTicc.jpg}
	\caption{Méta modèle de la syntaxe de Ticc utile pour le projet}
	\label{figureMMTicc}

\end{figure}

\subsection{Les règles ATL}

Après génération des deux méta modèles intervient l'écriture des règles ATL permettant le passage d'un diagramme de séquences à un automate d'interface.

Un algorithme permettant le passage d'un diagramme de séquences en un automate d'interface était fourni en début de projet. Cependant l'application d'un algorithme itératif récursif en règles ATL n'est pas possible du fait de la conception d'ATL utilisant EMF\protect\footnote{Eclipse Modeling Framework : framework de modélisation d'eclipse} qui utilise des modèles de données structurées.

Pour l'exécution d'ATL, ce qu'il faut savoir c'est qu'il prend en entrée un fichier de type \textit{XMI}\protect\footnote{XML Metadata Interchange : format standard de représentation de modèles UML basé sur XML} et génère en sortie un fichier du même type.

Comme annoncé en début de~\ref{subsubMMDiagSeq}, les échanges d'un composant se font entre lui et un composant abstrait appelé \textit{Environnement}. Il représente tous les autres composants émettant ou réceptionnant des messages du composant étudié dans la séquence. La figure~\ref{diagSeqExemple} permet d'illustrer un échange de ce type.

\clearpage

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.5]{diagSeqExemple.png}
    \caption{Exemple de diagramme de séquences}
    \label{diagSeqExemple}

\end{figure}

En reprenant les deux méta modèles vus précédemment (figures~\ref{figureMMDiagSeq} et~\ref{figureMMTicc}), on peut constater des similitudes qui permettent de faire les transformations. La figure~\ref{figureSimilitude} permet d'avoir, via des méta modèles simplifiés, une vue des éléments qui subiront une transformation avec une règle ATL.

\begin{figure}[!ht]
    \centering
    \includegraphics[scale=0.70]{figureSimilitudeSeqTicc.png}
    \caption{Similitude du méta modèle du diagramme de séquences avec celui de Ticc}
    \label{figureSimilitude}

\end{figure}

\noindent Les règles sont les suivantes : 
\begin{itemize}
	\item Le diagramme de séquences devient un modèle Ticc, toutes les séquences qu'il contient deviennent des éléments de type module que possède le modèle Ticc;
	\item Une séquence du diagramme de séquence devient un module :
    \begin{itemize}
        \item[$\bullet$] le nom du module est le même que celui de la séquence;
        \item[$\bullet$] le nombre d'états possédé correspond au nombre de \textit{NamedElement};
        \item[$\bullet$] l'état initial correspond à l'émetteur du premier message de la séquence;
        \item[$\bullet$] les transitions du modèle Ticc sont en correspondance avec les éléments de type \textit{Message} du modèle du diagramme de séquences.

    \end{itemize}

    \item Un message devient une transition de type \textit{LocalInput} ou \textit{Output} en fonction de l'émetteur ou du récepteur du message :
    \begin{itemize}
        \item[$\bullet$] il devient une transition \textit{LocalInput} si l'émetteur du message est le \textit{NamedElement} nommé \textit{Environnement};
        \item[$\bullet$] il devient une transition \textit{Output} si le récepteur du message est le \textit{NamedElement} nommé \textit{Environnement};
        \item[$\bullet$] le nom de la transition est celui de la méthode qu'appelle le message;
        \item[$\bullet$] la source et la destination d'une transition sont respectivement l'émetteur et le receveur d'un message.

    \end{itemize}

\end{itemize}

Pour la validité de ces règles, il convient bien sûr que seuls les messages émis par le composant voulu et les messages qu'il reçoit sont intéressant. Les autres sont ignorés.

Un fichier d'entrée exemple, un fichier de sortie et le fichier des règles ATL sont disponibles en annexe (\ref{fichierExempleEntree}, \ref{fichierExempleSortie} et \ref{regleATL}).

\subsection{Parseur XML vers Ticc}

Afin de pouvoir utiliser Ticc pour vérifier la compatibilité des composants, il est nécessaire de convertir le fichier XMI obtenu en sortie en un fichier .si compatible avec Ticc. Pour ce faire, un parseur XML a été implémenté. 
Il permet de récupérer un fichier XMI en entrée, et s'il est syntaxiquement correct, un fichier .si associé est généré ainsi qu'un fichier d'exécution .in. Ces fichiers peuvent eux aussi être trouvés en annexe (\ref{fichierParseSI} et \ref{fichierParseIN}).

\label{compatibiliteAutomate}

\subsection{Processus de transformation}

Comme déjà établi tout au long du rapport, le schéma~\ref{ProcessusTransformation} ci-dessous permet de visualiser les différentes étapes de transformations de modèles, ainsi que l'implémentation réalisée dans le projet. 

\clearpage

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.6]{vueEnsemble.png}
	\caption{Processus de transformation d'un diagramme SysML en automate d'interface Ticc}
	\label{ProcessusTransformation}

\end{figure}

Le processus commence avec deux bloc issus du BDD qui forment un diagramme de séquences. Lui-même est traduit en fichier XMI suivant les règles ATL. Ce fichier est ensuite transformé en modèle Ticc (également sous format XMI). A l'aide d'un parseur JDom, le modèle Ticc est transformé sous la syntaxe Ticc en un automate d'interface. Le fichier executable .in produit peut ensuite être interprété par Ticc pour la vérification de la compatibilité.

\clearpage
