\chapter{Construction d'automates d'interfaces}

Le but principal du projet est, partant d'un diagramme de définition de blocs, de récupérer deux blocs interagissant ensembles et de pouvoir valider le fait qu'ils soient compatibles l'un avec l'autre.

Les automates d'interfaces des composants permettent de tester si deux composants sont compatibles. L'outil Ticc sera utilisé afin de tester la compatibilité entre deux automates d'interfaces. 
Le diagramme de séquences d'un bloc SysML est connu, il faut donc obtenir d'après ce diagramme de séquences, un fichier pouvant être lu par Ticc.
ATL entre en jeu à ce moment, il permet d'effectuer des transformations de modèles : ici le passage d'un diagramme de séquences à un fichier correspondant à la syntaxe de Ticc. 

\noindent En récapitulant, pour tester la compatibilité de deux blocs il faut :
\begin{itemize}
    \item générer un méta modèle du diagramme de séquences;
    \item générer un méta modèle correspondant à la syntaxe de Ticc;
    \item écrire les règles ATL permettant le passage d'un diagramme de séquences à un fichier Ticc;
    \item appliquer les règles ATL sur un fichier contenant les diagrammes de séquences de deux blocs (appelés par la suite composants), ce fichier doit être conforme au méta modèle du diagramme de séquences;
    \item parser le fichier obtenu après application des règles pour obtenir un fichier compatible Ticc contenant les deux composants;
    \item générer un fichier d'exécution Ticc en OCaml;
    \item lancer le fichier d'exécution dans Ticc et conclure sur la compatibilité des composants.

\end{itemize}

\section{Introduction {\`a} la transformation de mod{\`e}les}

Parmi les nombreux sujets de recherche existants, la conception et l'utilisation de mod{\`e}les font parti de ceux qui sont en pleine expansion. Le but de cette recherche {\'e}tant l'utilisation continue et syst{\'e}matique de ces mod{\`e}les tout au long d'un projet. L'un des aspects les plus importants {\'e}tant la g{\'e}n{\'e}ration et la transformation de mod{\`e}les {\`a} partir de r{\`e}gles. Il sera ainsi pr{\'e}sent{\'e} dans la suite de cette section, les diff{\'e}rentes approches de la transformation de mod{\`e}les, dont le but est d'introduire la transformation d'un diagramme de s{\'e}quence SysML vers un automate d'interfaces Ticc.

\subsection{Transformation endog{\`e}ne}

Une transformation endog{\`e}ne (ou raffinement) de mod{\`e}le consiste {\`a} modifier le contenu d'un mod{\`e}le sans en changer le but ou la s{\'e}mantique. Il s'agit de rajouter des d{\'e}tails {\`a} un mod{\`e}le ou bien de le restructurer pour en am{\'e}liorer la conception. Par principe, le raffinement implique que les deux mod{\`e}les, le mod{\`e}le source et le mod{\`e}le cible, soient du m{\^e}me type, c'est-{\`a}-dire conformes au m{\^e}me m{\'e}ta mod{\`e}le.

\noindent La figure~\ref{raffinement} ci-dessous repr{\'e}sente ce concept :

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.8]{endogene.png}
	\caption{Sch{\'e}ma d'une transformation endog{\`e}ne (ou par raffinement)}
	\label{raffinement}

\end{figure}

\subsection{Transformation exog{\`e}ne}

Il s'agit d'une transformation entre deux espaces technologiques diff{\'e}rents. Les mod{\`e}les source et cible sont conformes {\`a} des m{\'e}ta-mod{\`e}les diff{\'e}rents. Par exemple la conversion d'un fichier XML en un sch{\'e}ma BDD.

\noindent C'est cette configuration de transformation qui a {\'e}t{\'e} mise en {\oe}uvre dans le projet. La figure~\ref{projection} ci-dessous repr{\'e}sente ce concept : 

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.8]{exogene.png}
	\caption{Sch{\'e}ma d'une transformation exog{\`e}ne (ou par projection)}
	\label{projection}

\end{figure}

\subsection{Transformation g{\'e}n{\'e}rique}

Ce type de transformation se base sur les m{\'e}ta m{\'e}ta mod{\`e}les (mod{\`e}le MOF\protect\footnote{Meta-Object Facility}) et produit un mod{\`e}le cible g{\'e}n{\'e}rique, qui peut {\^e}tre r{\'e}utilisable. Elle peut {\^e}tre exog{\`e}ne ou endog{\`e}ne.

\subsection{Query}

La transformation de mod{\`e}le query est un type de transformation qui permet la transformation d'un m{\'e}ta mod{\`e}le en texte (documentation ou code source).

\noindent Par exemple :
\begin{itemize}
	\item transformer un mod{\`e}le UML vers du code Java;
	\item contr{\^o}ler la coh{\'e}rence d'un mod{\`e}le UML en écrivant une transformation qui affiche un diagnostic.
	
\end{itemize}

\section{Réalisation}

\subsection{ATL : un choix technique}

L'utilisation d'ATL, pour la récupération et le traitement d'un fichier Ticc contenant deux composants, requiert :
\begin{itemize}
    \item deux méta modèles en entrée : un de base (celui du diagramme de séquences) et un d'arrivé (celui du langage Ticc);
    \item un fichier conforme au méta modèle de base;
    \item les règles ATL permettant de passer du méta modèle de base au méta modèle voulu.

\end{itemize}

\subsection{Les méta modèles}

\subsubsection{Méta modèle du diagramme de séquences}
\label{subsubMMDiagSeq}

Le méta modèle de séquence existant n'a pas été pris dans son ensemble, seules les parties importantes ont été extraites.
Par principe, les messages échangés se font entre un composant et son environnement.

\noindent Les ensembles de messages pris en compte sont :
\begin{itemize}
    \item \textbf{alt} : messages multiples alternatifs (si alors sinon);
    \item \textbf{loop} : messages s'exécutant plusieurs fois (boucle);
    \item \textbf{seq} : messages n'ayant pas d'ordre particulier.

\end{itemize}

Ces ensembles peuvent contenir eux-mêmes d'autres ensembles contenant des messages. Un message est composé d'un émetteur et d'un récepteur. Il possède aussi une méthode associée qui possède un nom.

Une séquence type pour le diagramme de séquences, dont il est question d'utiliser dans le cadre du projet, sera composée de différents composants \textit{NamedElement}, de messages \textit{Message} et éventuellement d'ensembles de messages \textit{TypeMessage}.
La figure~\ref{figureMMDiagSeq} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.62]{MMDiagSeq.jpg}
	\caption{Méta modèle du diagramme de séquences utile pour le projet}
	\label{figureMMDiagSeq}

\end{figure}

\subsubsection{Méta modèle du langage de Ticc}

Concernant Ticc, le méta modèle a été créé en se basant sur la syntaxe du logiciel et après analyse des fichiers exemples. En effet, Ticc permet de traiter des automates dît sociaux, pouvant communiquer entre eux. Or cette notion n'est pas utile dans le cadre du projet, elle a donc, de ce fait, été écartée du méta modèle.

Le code ci-dessous représente comme vu dans la partie~\ref{utilisationTicc} un module.
\lstinputlisting{./doc/moduleExemple.si}

Un module porte un nom et est donc composé d'un tableau représentant les différents états de l'automate. Il peut aussi avoir un état initial.
Il contient ensuite les différentes transitions possibles de l'automate :
\begin{itemize}
	\item \textbf{Input} une transition d'entrée de l'automate qui peut être décomposée en deux types :
	\begin{itemize}
		\item[$\bullet$] \textbf{GlobalInput} principalement utilisée pour les automates sociaux, elle peut représenter aussi des entrées ne faisant pas changer l'état de l'automate;
		\item[$\bullet$] \textbf{LocalInput} cette transition représente une entrée dans l'automate entrainant ou non un changement d'état interne.
	
	\end{itemize}
	\item \textbf{Output} une transition de sortie de l'automate;
	\item \textbf{Local} une transition interne de l'automate.
				
\end{itemize}

Dans le cas d'un changement d'état, l'état suivant est noté d'un \' (voir l'exemple ci-dessus avec \textbf{s'}).

\clearpage

\noindent La figure~\ref{figureMMTicc} représente le méta modèle réfléchit dans le cadre du projet.

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.62]{MMTicc.jpg}
	\caption{Méta modèle de la syntaxe de Ticc utile pour le projet}
	\label{figureMMTicc}

\end{figure}

%TODO a completer avec reference fichier Ticc

\subsection{Les règles ATL}

Après génération des deux méta modèles intervient l'écriture des règles ATL permettant le passage d'un diagramme de séquences à un automate d'interface.

Un algorithme permettant le passage d'un diagramme de séquences en un automate d'interface était fourni en début de projet. Cependant l'application d'un algorithme itératif récursif en règles ATL n'est pas possible du fait de la conception d'ATL utilisant EMF\protect\footnote{Eclipse Modeling Framework : framework de modélisation d'eclipse} qui utilise des modèles de données structurées.

Pour l'exécution d'ATL, ce qu'il faut savoir c'est qu'il prend en entrée un fichier de type \textit{XMI}\protect\footnote{XML Metadata Interchange : format standard de représentation de modèles UML basé sur XML} et génère en sortie un fichier du même type.

Comme annoncé en début de~\ref{subsubMMDiagSeq}, les échanges d'un composant se font entre lui et un composant abstrait appelé \textit{Environnement}. Il représente tous les autres composants émettant ou réceptionnant des messages du composant étudié dans la séquence.

\noindent Les règles sont les suivantes : 
\begin{itemize}
	\item Le diagramme de séquences devient un modèle Ticc;
	\item Les séquences du diagramme de séquences deviennent des modules;
	\item Les messages en fonction de l'émetteur et du récepteur deviennent des transitions d'entrée ou de sortie : un message provenant du composant \textit{Environnement} correspond à une transition d'entrée.

\end{itemize}

% ANNEXE !!!!
Le fichier d'entrée exemple, le fichier des règles ATL et le fichier de sortie sont disponibles en annexe (\ref{fichierExempleEntree}, \ref{regleATL} et \ref{fichierExempleSortie}).

\subsection{Parseur XML vers Ticc}

Afin de pouvoir utiliser Ticc pour vérifier la compatibilité des composants, il est nécessaire de convertir le fichier XMI obtenu en sortie en un fichier .si compatible avec Ticc. Pour ce faire, un parseur XML a été implémenté. 
Il permet de récupérer un fichier XMI en entrée, et s'il est syntaxiquement correcte, un fichier .si associé est généré ainsi qu'un fichier d'exécution .in. Ces fichiers peuvent eux aussi être trouvés en annexe (\ref{fichierParseSI} et \ref{fichierParseIN}).

\label{compatibiliteAutomate}

\subsection{Processus de transformation}

Comme déjà établi tout au long du rapport, le schéma~\ref{ProcessusTransformation} ci-dessous permet de visualiser les différentes étapes de transformations de modèles, ainsi que l'implémentation réalisée dans le projet. 

\begin{figure}[!ht]
	\centering
	\includegraphics[scale=0.7]{ProcessusTransformation2.png}
	\caption{Processus de transformation d'un diagramme SysML en automate d'interface Ticc}
	\label{ProcessusTransformation}

\end{figure}

Le diagramme de séquence traduit en fichier XMI suit les règles ATL pour être transformé en modèle Ticc également sous format XMI. A l'aide d'un parseur JDom, le modèle Ticc est transformé sous la syntaxe Ticc en un automate d'interface. Le fichier executable .in produit peut ensuite être interprété par Ticc pour la vérification de la compatibilité.

\clearpage
